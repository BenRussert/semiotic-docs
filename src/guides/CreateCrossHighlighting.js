import React from "react";
import MarkdownText from "../MarkdownText";
import DocumentFrame from "../DocumentFrame";
import { XYFrame } from "semiotic";

import { frameProps, overrideProps } from "./CreateALineChart";

export default () => {
  return (
    <div>
      <MarkdownText
        text={`
Highlighting is a type of [annnotation](/guides/annotations), \`{type:"highlight"}\` that duplicates a mark to the annotation layer for styling. 

A common use case is for highlighting something while dimming out other elements, or for cross-highlighting.

You can send this annotation two ways.


If you want the highlight only on hover, instead of passing \`hoverAnnotation={true}\` on your frame, you can pass an object \`hoverAnnotation=[{ type: "highlight", style: {strokeWidth: 10} }]\`


In XYFrame it uses the function in \`lineIDAccessor\` to evaluate what objects to highlight and will render that shape (or shapes) in the AnnotationLayer with style and class defined by the annotation. 


Move your mouse over the chart to see the line highlighted.

      `}
      />
      <DocumentFrame
        frameProps={{
          ...frameProps,
          hoverAnnotation: [
            {
              type: "highlight",
              style: { strokeWidth: 10 }
            }
          ],
          lineIDAccessor: "title"
        }}
        type={XYFrame}
        overrideProps={overrideProps}
        startHidden
      />
      <MarkdownText
        text={`

For highlighting regardless of interactions, send an annotation to the annotations prop and specific the matching \`lineIDAccessor\` in your annotation \`annotations=[{ type: "highlight", style: {strokeWidth: 10}, title: "Ex Machina"}]\`

      `}
      />
      <DocumentFrame
        frameProps={{
          ...frameProps,
          annotations: [
            {
              type: "highlight",
              title: "Ex Machina",
              style: { strokeWidth: 10, fill: "blue" }
            }
          ],
          lineIDAccessor: "title"
        }}
        type={XYFrame}
        overrideProps={overrideProps}
        startHidden
      />

      <MarkdownText
        text={`

Style can be a React style object or function returning a React style object and class can be a string or function returning a string. 

All highlight annotations created in the annotation layer will always have "highlight-annotation" class in addition to any passed classes.

    

## Dynamic Styles

The annotation honors a style prop that can be a React style object or a function that returns a React style object and evaluates the annotation. Because dynamically produced hover annotations are generated with the hover item's data, this lets you create custom styles. This also passes a frame-hover to the hoverAnnotation settings, showing off the ability to pass multiple annotation types to hoverAnnotation. Nothing else is changed from the previous example.


    `}
      />

      <DocumentFrame
        frameProps={{
          ...frameProps,
          hoverAnnotation: [
            {
              type: "highlight",
              style: d => {
                return { ...frameProps.lineStyle(d, d.key), strokeWidth: 5 };
              }
            }
          ],
          lineIDAccessor: "title"
        }}
        type={XYFrame}
        overrideProps={overrideProps}
        startHidden
      />

      <MarkdownText
        text={`
## Desaturation Layer

Using the \`highlight\`annotation in tandem with the \`deaturation-layer\` annotation allows you to create the effect of dimming the background when hovering.
  `}
      />

      <DocumentFrame
        frameProps={{
          ...frameProps,
          hoverAnnotation: [
            {
              type: "desaturation-layer",
              style: { fill: "white", opacity: 0.6 }
            },
            {
              type: "highlight",
              style: d => {
                return { ...frameProps.lineStyle(d, d.key), strokeWidth: 5 };
              }
            }
          ],
          lineIDAccessor: "title"
        }}
        type={XYFrame}
        overrideProps={overrideProps}
        startHidden
      />

      <MarkdownText
        text={`

## Cross Highlighting
Frames have custom interaction using customHoverBehavior, customClickBehavior and customDoubleClickBehavior. You can use these to take the value of the hovered or clicked item and pass a highlight annotation made from that data object to the annotations property of another frame to achieve cross-highlighting. These two frames have different sizes and different lineTypes but otherwise the only change is in the


## Point and Area Highlighting
Highlight annotations will return all points, lines and areas that match the id value of the passed highlight. This can be used to highlight multiple shapes if your lineIDAccessor is sophisticated (or simple) enough. Here I check in lineIDAccessor not only for title but if the object has a parentLine (indicating a point generated by showLinePoints) to match against the parentLine title value.

## OrinalFrame Highlighting
OrdinalFrames get highlighting, too. The second example uses classes with a defined gradient in CSS. Unlike in XYFrame, there's already one built-in id accessor in OrdinalFrame: oAccessor, additionally if you define a pieceIDAccessor you can use that to highlight individual pieces (this is the same property used to annotate specific pieces with other OrdinalFrame annotatinos). Without a pieceIDAccessor defined, all items in a column/row will be highlighted.

Highlighting is not available for custom graphics or summary graphics.

## Highlighting Across Categories 
You don't have to send annotations with valid oAccessor or pieceIDAccessor traits. If you do, they will highlight all the pieces that satisfy the one you do send. This example has two annotations sent that highlight all the pieces in one column as well as all pieces of a certain type across all four columns.

## Scatterplot Highlighting 
    `}
      />
    </div>
  );
};
